<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HTML Table → Markdown (First Table From URL)</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f111a;
      --panel: #151827;
      --panel2: #101326;
      --text: #e6e6e6;
      --muted: #aeb6cf;
      --border: rgba(255,255,255,0.12);
      --accent: #4da3ff;
      --danger: #ff5d5d;
      --ok: #38d996;
      --shadow: 0 10px 30px rgba(0,0,0,0.45);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 600px at 20% 10%, rgba(77,163,255,0.16), transparent 55%),
                  radial-gradient(900px 500px at 75% 25%, rgba(56,217,150,0.10), transparent 50%),
                  var(--bg);
      color: var(--text);
    }

    header {
      padding: 22px 20px 10px;
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      margin: 0 0 8px;
      font-weight: 650;
      font-size: 18px;
      letter-spacing: 0.2px;
    }

    header p {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }

    main {
      max-width: 1200px;
      margin: 0 auto;
      padding: 14px 20px 26px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .panel .title {
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,0.18);
      font-size: 13px;
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .panel .body {
      padding: 14px;
    }

    label {
      display: block;
      color: var(--muted);
      font-size: 12px;
      margin: 0 0 6px;
    }

    input[type="text"], textarea, select {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.25);
      color: var(--text);
      padding: 10px 12px;
      font-size: 13px;
      outline: none;
    }

    input[type="text"]:focus, textarea:focus, select:focus {
      border-color: rgba(77,163,255,0.6);
      box-shadow: 0 0 0 3px rgba(77,163,255,0.18);
    }

    textarea {
      min-height: 180px;
      resize: vertical;
      font-family: var(--mono);
      line-height: 1.35;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    @media (min-width: 980px) {
      main {
        grid-template-columns: 1fr 1fr;
        align-items: start;
      }
      .row {
        grid-template-columns: 2fr 1fr;
        align-items: end;
      }
    }

    .actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(77,163,255,0.28), rgba(77,163,255,0.12));
      color: var(--text);
      padding: 9px 12px;
      border-radius: 10px;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.06s ease, border-color 0.06s ease;
    }

    button:hover { border-color: rgba(77,163,255,0.55); }
    button:active { transform: translateY(1px); }

    button.secondary {
      background: rgba(255,255,255,0.06);
    }

    button.danger {
      background: linear-gradient(180deg, rgba(255,93,93,0.22), rgba(255,93,93,0.10));
    }

    .status {
      font-family: var(--mono);
      font-size: 12px;
      white-space: pre-wrap;
      color: var(--muted);
    }

    .status .ok { color: var(--ok); }
    .status .err { color: var(--danger); }

    .hint {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
      margin-top: 10px;
    }

    code.inline {
      font-family: var(--mono);
      font-size: 12px;
      background: rgba(255,255,255,0.07);
      border: 1px solid var(--border);
      padding: 2px 6px;
      border-radius: 8px;
    }

    a { color: var(--accent); }
  </style>
</head>
<body>
  <header>
    <h1>HTML Table → Markdown (first table from a URL)</h1>
    <p>
      Paste a URL (optionally with <code class="inline">#anchor</code>). The tool fetches the page HTML, locates the first relevant
      table (or the table labelled by the anchor), extracts the title + text above it, and renders Markdown.
    </p>
  </header>

  <main>
    <section class="panel">
      <div class="title">
        <span>Input</span>
        <span style="opacity:0.9">Static HTML • runs in-browser</span>
      </div>
      <div class="body">
        <div class="row">
          <div>
            <label for="url">Page URL (can include #anchor)</label>
            <input id="url" type="text" spellcheck="false"
              value="https://learn.microsoft.com/en-us/rest/api/searchservice/skillsets/get?view=rest-searchservice-2025-11-01-preview&tabs=HTTP#searchindexerskillset" />
          </div>
          <div>
            <label for="fetchMode">Fetch mode (CORS)</label>
            <select id="fetchMode">
              <option value="allorigins" selected>AllOrigins proxy (recommended)</option>
              <option value="everyorigin">EveryOrigin proxy (JSON)</option>
              <option value="localcorsproxy">Local CORS Proxy (local-cors-proxy)</option>
              <option value="direct">Direct fetch (works only if CORS allows)</option>
              <option value="jina">Jina AI proxy (fallback)</option>
            </select>
          </div>
        </div>

        <div style="margin-top: 12px;">
          <label for="localProxyOrigin">Local proxy origin (used for local-cors-proxy mode)</label>
          <input id="localProxyOrigin" type="text" spellcheck="false" value="http://localhost:8010/proxy" />
        </div>

        <div style="margin-top: 12px;">
          <label for="htmlOverride">Optional: paste HTML instead of fetching</label>
          <textarea id="htmlOverride" spellcheck="false" placeholder="If a site blocks fetching, paste the page HTML here and click Convert."></textarea>
        </div>

        <div class="actions" style="margin-top: 12px;">
          <button id="convert">Convert</button>
          <button id="copy" class="secondary" disabled>Copy Markdown</button>
          <button id="clear" class="danger">Clear</button>
        </div>

        <div class="hint">
          Notes:
          <ul>
            <li>Many sites (including docs) block browser <code class="inline">fetch</code> from local files due to CORS. Use the proxy mode or paste HTML.</li>
            <li>If a URL contains <code class="inline">#anchor</code>, the converter tries <code class="inline">table[aria-labelledby=&quot;anchor&quot;]</code> first, then the next table after the anchor.</li>
            <li>EveryOrigin returns JSON like <code class="inline">{ &quot;html&quot;: &quot;...&quot; }</code>; this tool will read the <code class="inline">html</code> field.</li>
            <li>
              Local CORS proxy setup: install <code class="inline">local-cors-proxy</code> using <code class="inline">npm install -g local-cors-proxy</code> and run
              <code class="inline">lcp --proxyUrl https://learn.microsoft.com --port 8010</code>.
              Then select “Local CORS Proxy” and keep <code class="inline">http://localhost:8010/proxy</code> as the local proxy origin.
            </li>
          </ul>
        </div>

        <div id="status" class="status" style="margin-top: 10px;"></div>
      </div>
    </section>

    <section class="panel">
      <div class="title">
        <span>Markdown output</span>
        <span id="meta" style="color: var(--muted);"></span>
      </div>
      <div class="body">
        <textarea id="out" spellcheck="false" placeholder="Markdown will appear here..."></textarea>
      </div>
    </section>
  </main>

  <script>
    const elUrl = document.getElementById('url');
    const elFetchMode = document.getElementById('fetchMode');
    const elLocalProxyOrigin = document.getElementById('localProxyOrigin');
    const elHtmlOverride = document.getElementById('htmlOverride');
    const elConvert = document.getElementById('convert');
    const elCopy = document.getElementById('copy');
    const elClear = document.getElementById('clear');
    const elStatus = document.getElementById('status');
    const elOut = document.getElementById('out');
    const elMeta = document.getElementById('meta');

    function setStatus(message, kind) {
      const prefix = kind === 'ok' ? 'ok' : kind === 'err' ? 'err' : '';
      elStatus.innerHTML = prefix ? `<span class="${prefix}">${escapeHtml(message)}</span>` : escapeHtml(message);
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function cssEscape(value) {
      // Minimal CSS.escape polyfill for ids.
      const s = String(value);
      return s.replace(/[^a-zA-Z0-9_\u00A0-\uFFFF-]/g, (ch) => `\\${ch}`);
    }

    function normalizeWhitespace(text) {
      return text
        .replace(/\u00A0/g, ' ')
        .replace(/[ \t\r\f\v]+/g, ' ')
        .replace(/\s*\n\s*/g, '\n')
        .trim();
    }

    function getText(el) {
      if (!el) return '';
      const cloned = el.cloneNode(true);
      cloned.querySelectorAll('wbr').forEach(n => n.remove());
      return normalizeWhitespace(cloned.textContent || '');
    }

    function getAnchorIdFromUrl(url) {
      const u = new URL(url);
      const hash = u.hash ? u.hash.slice(1) : '';
      u.hash = '';
      return { baseUrl: u.toString(), anchorId: decodeURIComponent(hash) };
    }

    function buildFetchUrl(inputUrl, fetchMode) {
      if (fetchMode === 'direct') return inputUrl;
      if (fetchMode === 'allorigins') {
        return `https://api.allorigins.win/raw?url=${encodeURIComponent(inputUrl)}`;
      }
      if (fetchMode === 'everyorigin') {
        return `https://every-origin.vercel.app/api/get?url=${encodeURIComponent(inputUrl)}`;
      }
      if (fetchMode === 'localcorsproxy') {
        // local-cors-proxy proxies a single origin; request must be the path+query.
        // Example local server: lcp --proxyUrl https://learn.microsoft.com --port 8010
        // Example request: http://localhost:8010/proxy/en-us/rest/api/...
        const origin = (elLocalProxyOrigin && elLocalProxyOrigin.value ? elLocalProxyOrigin.value : 'http://localhost:8010/proxy').trim().replace(/\/+$/g, '');
        const u = new URL(inputUrl);
        return `${origin}${u.pathname}${u.search}`;
      }
      if (fetchMode === 'jina') {
        // Example: https://r.jina.ai/https://learn.microsoft.com/...
        return `https://r.jina.ai/${inputUrl}`;
      }
      return inputUrl;
    }

    async function fetchHtml(url, fetchMode) {
      const fetchUrl = buildFetchUrl(url, fetchMode);
      const res = await fetch(fetchUrl, {
        method: 'GET',
        headers: { 'Accept': 'text/html,*/*' }
      });
      if (!res.ok) {
        throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);
      }

      if (fetchMode === 'everyorigin') {
        const data = await res.json();
        const html = (data && (data.html || data.contents)) ? String(data.html || data.contents) : '';
        if (!html) {
          throw new Error('EveryOrigin response did not contain an "html" field.');
        }
        return html;
      }

      return await res.text();
    }

    function parseHtmlToDocument(html) {
      const parser = new DOMParser();
      return parser.parseFromString(html, 'text/html');
    }

    function findHeadingForTable(doc, table, anchorId) {
      if (!table) return null;

      if (anchorId) {
        const aria = table.getAttribute('aria-labelledby');
        if (aria) {
          const byAria = doc.getElementById(aria);
          if (byAria && /^H[1-6]$/i.test(byAria.tagName)) return byAria;
          if (byAria) {
            const heading = byAria.closest('h1,h2,h3,h4,h5,h6');
            if (heading) return heading;
          }
        }

        const anchorEl = doc.getElementById(anchorId) || doc.querySelector(`[name="${cssEscape(anchorId)}"]`);
        if (anchorEl) {
          if (/^H[1-6]$/i.test(anchorEl.tagName)) return anchorEl;
          const heading = anchorEl.closest('h1,h2,h3,h4,h5,h6');
          if (heading) return heading;
        }
      }

      // Fallback: walk backwards to find nearest heading.
      let node = table;
      while (node) {
        let prev = node.previousElementSibling;
        while (prev) {
          if (/^H[1-6]$/i.test(prev.tagName)) return prev;
          prev = prev.previousElementSibling;
        }
        node = node.parentElement;
      }

      return null;
    }

    function findDescriptionTextAboveTable(headingEl, tableEl) {
      if (!tableEl) return '';

      // Prefer paragraphs between heading and table.
      if (headingEl) {
        let node = headingEl.nextElementSibling;
        while (node && node !== tableEl) {
          const tag = node.tagName ? node.tagName.toLowerCase() : '';
          if (tag === 'p') {
            const t = getText(node);
            if (t) return t;
          }
          if (tag === 'table') break;
          node = node.nextElementSibling;
        }
      }

      // Fallback: previous paragraph sibling.
      let prev = tableEl.previousElementSibling;
      while (prev) {
        const tag = prev.tagName ? prev.tagName.toLowerCase() : '';
        if (tag === 'p') {
          const t = getText(prev);
          if (t) return t;
        }
        if (/^h[1-6]$/.test(tag)) break;
        prev = prev.previousElementSibling;
      }

      return '';
    }

    function findTargetTable(doc, anchorId) {
      if (anchorId) {
        const byLabel = doc.querySelector(`table[aria-labelledby="${cssEscape(anchorId)}"]`);
        if (byLabel) return byLabel;

        const anchorEl = doc.getElementById(anchorId) || doc.querySelector(`[name="${cssEscape(anchorId)}"]`);
        if (anchorEl) {
          // Find the first table AFTER the anchor in document order.
          const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT);

          let foundAnchor = false;
          while (walker.nextNode()) {
            const el = /** @type {HTMLElement} */ (walker.currentNode);
            if (!foundAnchor) {
              if (el === anchorEl) {
                foundAnchor = true;
              }
              continue;
            }
            if (el.tagName && el.tagName.toLowerCase() === 'table') return el;
          }

          // If the anchor isn't in body traversal (rare), fallback to a broad search.
          const afterAnchor = doc.querySelector('table');
          if (afterAnchor) return afterAnchor;
        }
      }

      return doc.querySelector('table');
    }

    function tryGetHeadingLevel(el) {
      if (!el || !el.tagName) return null;
      const m = /^H([1-6])$/i.exec(el.tagName);
      return m ? Number(m[1]) : null;
    }

    function resolveAnchorElement(doc, anchorId) {
      if (!anchorId) return null;
      return doc.getElementById(anchorId) || doc.querySelector(`[name="${cssEscape(anchorId)}"]`);
    }

    function findNextHeadingOfLevelOrHigher(doc, startHeading, startLevel) {
      if (!startHeading || !startLevel) return null;
      const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT);

      // Advance walker to the starting heading.
      while (walker.nextNode()) {
        if (walker.currentNode === startHeading) break;
      }

      while (walker.nextNode()) {
        const el = /** @type {HTMLElement} */ (walker.currentNode);
        const lvl = tryGetHeadingLevel(el);
        if (lvl !== null && lvl <= startLevel) return el;
      }

      return null;
    }

    function findFirstTableAfterWithinSection(doc, startEl, stopEl) {
      if (!startEl) return null;

      const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT);
      // Move to startEl
      while (walker.nextNode()) {
        if (walker.currentNode === startEl) break;
      }

      while (walker.nextNode()) {
        const el = /** @type {HTMLElement} */ (walker.currentNode);
        if (stopEl && el === stopEl) break;
        if (el.tagName && el.tagName.toLowerCase() === 'table') return el;
      }

      return null;
    }

    function findTableForAnchor(doc, anchorId) {
      if (!anchorId) return null;

      // Best case (MS Learn parameter/definition tables often use this)
      const byLabel = doc.querySelector(`table[aria-labelledby="${cssEscape(anchorId)}"]`);
      if (byLabel) return byLabel;

      const anchorEl = resolveAnchorElement(doc, anchorId);
      if (!anchorEl) return null;

      const heading = /^H[1-6]$/i.test(anchorEl.tagName)
        ? anchorEl
        : anchorEl.closest('h1,h2,h3,h4,h5,h6');

      const startEl = heading || anchorEl;
      const startLevel = tryGetHeadingLevel(heading);
      const stopHeading = startLevel ? findNextHeadingOfLevelOrHigher(doc, heading, startLevel) : null;

      return findFirstTableAfterWithinSection(doc, startEl, stopHeading);
    }

    function extractHashAnchorsFromElement(rootEl, baseUrl) {
      /** @type {string[]} */
      const anchors = [];
      if (!rootEl) return anchors;
      const links = Array.from(rootEl.querySelectorAll('a[href]'));
      for (const a of links) {
        const hrefRaw = (a.getAttribute('href') || '').trim();
        if (!hrefRaw) continue;

        let hash = '';
        if (hrefRaw.startsWith('#')) {
          hash = hrefRaw;
        } else {
          try {
            const u = new URL(hrefRaw, baseUrl || undefined);
            // Only handle anchors that point within the same document.
            const base = new URL(baseUrl || u.toString());
            base.hash = '';
            const uNoHash = new URL(u.toString());
            uNoHash.hash = '';
            if (base.toString() === uNoHash.toString() && u.hash) {
              hash = u.hash;
            }
          } catch {
            // ignore
          }
        }

        if (!hash.startsWith('#') || hash.length < 2) continue;
        const id = decodeURIComponent(hash.slice(1));
        if (!id) continue;
        anchors.push(id);
      }

      // Unique preserving order
      const seen = new Set();
      return anchors.filter(a => (seen.has(a) ? false : (seen.add(a), true)));
    }

    function toMarkdownLink(a, baseUrl) {
      const text = normalizeWhitespace(a.textContent || '').replace(/\u00AD/g, '');
      let href = a.getAttribute('href') || '';

      // Convert relative to absolute when it isn't a simple hash.
      try {
        if (href && !href.startsWith('#') && baseUrl) {
          href = new URL(href, baseUrl).toString();
        }
      } catch {
        // ignore
      }

      if (!href) return text;
      return `[${text}](${href})`;
    }

    function nodeToMarkdownInline(node, baseUrl) {
      if (!node) return '';

      if (node.nodeType === Node.TEXT_NODE) {
        return node.nodeValue || '';
      }

      if (node.nodeType !== Node.ELEMENT_NODE) {
        return '';
      }

      const el = /** @type {HTMLElement} */ (node);
      const tag = el.tagName.toLowerCase();

      if (tag === 'wbr') return '';

      if (tag === 'br') return '<br/>';

      if (tag === 'a') return toMarkdownLink(el, baseUrl);

      if (tag === 'code') {
        // Keep inline code readable inside tables (avoid backticks breaking markdown).
        return normalizeWhitespace(el.textContent || '');
      }

      if (tag === 'p' || tag === 'span' || tag === 'strong' || tag === 'em' || tag === 'small') {
        return Array.from(el.childNodes).map(n => nodeToMarkdownInline(n, baseUrl)).join('');
      }

      if (tag === 'ul' || tag === 'ol') {
        const items = Array.from(el.querySelectorAll(':scope > li')).map(li => {
          const liText = elementToMarkdownCell(li, baseUrl);
          return `-   ${liText}`;
        }).filter(Boolean);
        return items.length ? `<br/>${items.join('<br/>')}` : '';
      }

      if (tag === 'li') {
        return Array.from(el.childNodes).map(n => nodeToMarkdownInline(n, baseUrl)).join('');
      }

      // Default: flatten text.
      return Array.from(el.childNodes).map(n => nodeToMarkdownInline(n, baseUrl)).join('');
    }

    function elementToMarkdownCell(cellEl, baseUrl) {
      const text = Array.from(cellEl.childNodes).map(n => nodeToMarkdownInline(n, baseUrl)).join('');
      const normalized = normalizeWhitespace(text)
        .replace(/\n/g, '<br/>');

      // Escape markdown table pipes.
      return normalized.replaceAll('|', '\\|');
    }

    function tableToMarkdown(tableEl, baseUrl) {
      const rows = Array.from(tableEl.querySelectorAll('tr'));
      if (!rows.length) return '';

      const parsedRows = rows.map(tr => {
        const headerCells = Array.from(tr.querySelectorAll(':scope > th'));
        const dataCells = Array.from(tr.querySelectorAll(':scope > td'));
        const cells = (headerCells.length ? headerCells : dataCells);
        return cells.map(td => elementToMarkdownCell(td, baseUrl));
      }).filter(r => r.length > 0);

      if (!parsedRows.length) return '';

      let header = parsedRows[0];
      let body = parsedRows.slice(1);

      // If first row isn't headers but contains td only, still treat as header.
      const sep = header.map(() => '---');

      const lines = [];
      lines.push(`| ${header.join(' | ')} |`);
      lines.push(`| ${sep.join(' | ')} |`);
      for (const r of body) {
        // pad rows to header length
        const padded = r.slice();
        while (padded.length < header.length) padded.push('');
        lines.push(`| ${padded.join(' | ')} |`);
      }
      return lines.join('\n');
    }

    function convert(html, originalUrl) {
      const { anchorId } = getAnchorIdFromUrl(originalUrl);
      const doc = parseHtmlToDocument(html);

      const { baseUrl } = getAnchorIdFromUrl(originalUrl);

      const mainTable = findTargetTable(doc, anchorId);
      if (!mainTable) {
        throw new Error('No <table> found on the page (or near the anchor).');
      }

      const blocks = [];
      const visitedAnchors = new Set();
      const queuedAnchors = [];

      // Prevent re-processing the starting anchor as a linked table.
      if (anchorId) visitedAnchors.add(anchorId);

      function addTableBlock(tableEl, tableAnchorId) {
        const headingEl = findHeadingForTable(doc, tableEl, tableAnchorId);
        const title = getText(headingEl) || (tableAnchorId ? tableAnchorId : '');
        const desc = findDescriptionTextAboveTable(headingEl, tableEl);
        const mdTable = tableToMarkdown(tableEl, baseUrl);

        let out = '';
        if (title) out += `## ${title}\n`;
        if (desc) out += `${desc}\n`;
        if (title || desc) out += '\n';
        out += mdTable;

        blocks.push(out.trim());

        // Collect anchors for recursive extraction.
        const nextAnchors = extractHashAnchorsFromElement(tableEl, baseUrl);
        for (const a of nextAnchors) {
          if (!visitedAnchors.has(a)) queuedAnchors.push(a);
        }

        return { title, desc };
      }

      const mainMeta = addTableBlock(mainTable, anchorId);

      let extraCount = 0;
      while (queuedAnchors.length) {
        const next = queuedAnchors.shift();
        if (!next) continue;
        if (visitedAnchors.has(next)) continue;
        visitedAnchors.add(next);

        const linkedTable = findTableForAnchor(doc, next);
        if (!linkedTable) continue;

        addTableBlock(linkedTable, next);
        extraCount++;
      }

      const out = blocks.join('\n\n') + '\n';

      return {
        markdown: out,
        meta: {
          title: mainMeta.title,
          anchorId,
          linkedTablesAdded: extraCount,
          tableAriaLabelledBy: mainTable.getAttribute('aria-labelledby') || ''
        }
      };
    }

    async function onConvert() {
      elCopy.disabled = true;
      elOut.value = '';
      elMeta.textContent = '';
      setStatus('Working...', '');

      const url = (elUrl.value || '').trim();
      if (!url) {
        setStatus('Enter a URL first.', 'err');
        return;
      }

      let html = (elHtmlOverride.value || '').trim();
      try {
        if (!html) {
          const { baseUrl } = getAnchorIdFromUrl(url);
          html = await fetchHtml(baseUrl, elFetchMode.value);
        }
        const { markdown, meta } = convert(html, url);
        elOut.value = markdown;
        const anchorText = meta.anchorId ? `#${meta.anchorId}` : '(none)';
        const linked = typeof meta.linkedTablesAdded === 'number' ? meta.linkedTablesAdded : 0;
        elMeta.textContent = `anchor: ${anchorText} • linked tables: ${linked}`;
        elCopy.disabled = false;
        setStatus('Converted successfully.', 'ok');
      } catch (e) {
        setStatus(String(e && e.message ? e.message : e), 'err');
      }
    }

    async function onCopy() {
      const text = elOut.value;
      if (!text) return;
      try {
        await navigator.clipboard.writeText(text);
        setStatus('Copied to clipboard.', 'ok');
      } catch {
        // Fallback
        elOut.focus();
        elOut.select();
        document.execCommand('copy');
        setStatus('Copied (fallback).', 'ok');
      }
    }

    function onClear() {
      elHtmlOverride.value = '';
      elOut.value = '';
      elCopy.disabled = true;
      elMeta.textContent = '';
      setStatus('', '');
    }

    elConvert.addEventListener('click', onConvert);
    elCopy.addEventListener('click', onCopy);
    elClear.addEventListener('click', onClear);

    // Allow Ctrl/Cmd+Enter to convert.
    document.addEventListener('keydown', (e) => {
      const isEnter = e.key === 'Enter';
      const isShortcut = (e.ctrlKey || e.metaKey) && isEnter;
      if (isShortcut) {
        e.preventDefault();
        onConvert();
      }
    });

    // Auto convert once at load for the sample.
    setTimeout(() => { onConvert(); }, 50);
  </script>
</body>
</html>
